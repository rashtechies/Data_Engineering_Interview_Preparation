# -*- coding: utf-8 -*-
"""Advanced Python Tutorial.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1gCqFEquqNvEoTDX3SNhR2PZkXWPHKXnc

# Advanced Python Tutorial

In this tutorial, we will be exploring some advanced Python concepts and techniques using Google Colab.

## Table of Contents

### Section 1: Advanced Python Techniques
1. List Comprehensions
2. Lambda Functions
3. Map, Filter, and Reduce Functions
4. Decorators
5. Context Managers
6. Generators
7. Multithreading and Multiprocessing
8. Working with Files (Reading and Writing)
9. Regular Expressions
10. Error Handling and Exceptions

### Section 2: Classes
11. Classes and Objects
12. Inheritance
13. Property Decorators
14. Python's Data Model & Magic Methods

## 1. List Comprehensions

List comprehensions provide a concise way to create lists. It consists of an expression followed by a `for` statement inside square brackets. Here's an example:
"""

squares = [x * x for x in range(10)]

"""This creates a list of squares of numbers from 0 to 9. You can also add an optional `if` clause to filter the items:

```python
even_squares = [x * x for x in range(10) if x % 2 == 0]
```

This creates a list of squares of even numbers from 0 to 9.

### Exercise 1:

Use list comprehensions to create a list of cubes of odd numbers from 1 to 20.

```python
cubes = [x ** 3 for x in range(1, 21) if x % 2 != 0]
print(cubes)
```

## 2. Lambda Functions

Lambda functions are small, anonymous functions that can be created with the `lambda` keyword. They are useful when you need a simple function for a short period of time and don't want to define a full function using `def`. Lambda functions can take any number of arguments but can only have one expression.

```python
add = lambda x, y: x + y
print(add(5, 3))  # Output: 8
```

## 3. Map, Filter, and Reduce Functions

`map`, `filter`, and `reduce` are higher-order functions that take a function and a sequence (e.g., list, tuple) as input and perform specific operations on them.

### Map

The `map()` function applies a given function to each item of a sequence and returns an iterator.

```python
numbers = [1, 2, 3, 4, 5]
squares = map(lambda x: x * x, numbers)

# Convert the iterator to a list
squares_list = list(squares)
print(squares_list)  # Output: [1, 4, 9, 16, 25]
```

### Filter

The `filter()` function filters the items of a sequence based on a function that returns a boolean value.

```python
numbers = [1, 2, 3, 4, 5]
even_numbers = filter(lambda x: x % 2 == 0, numbers)

# Convert the iterator to a list
even_numbers_list = list(even_numbers)
print(even_numbers_list)  # Output: [2, 4]
```

### Reduce

The `reduce()` function reduces a sequence to a single value by applying a given function cumulatively to the items, from left to right. The `reduce()` function is available in the `functools` module.

```python
from functools import reduce

numbers = [1, 2, 3, 4, 5]
product = reduce(lambda x, y: x * y, numbers)
print(product)  # Output: 120 (1 * 2 * 3 * 4 * 5)
```

## 4. Decorators

Decorators are a way to modify the behavior of functions or classes. They allow you to wrap another function to extend its behavior without modifying its code.

Here's an example of a simple decorator that measures the execution time of a function:

```python
import time

def timing_decorator(func):
    def wrapper(*args, **kwargs):
        start_time = time.time()
        result = func(*args, **kwargs)
        end_time = time.time()
        print(f"{func.__name__} took {end_time - start_time:.5f} seconds to execute.")
        return result

    return wrapper

@timing_decorator
def slow_function():
    time.sleep(2)

slow_function()
```

## 5. Context Managers

Context managers are used to manage resources, such as file handles or network connections, that need to be acquired and released. They are typically used with the `with` statement to ensure that the resources are properly acquired and released.

Here's an example of a context manager for working with files:

```python
with open("file.txt", "r") as file:
    content = file.read()
    # Do something with the content
```

In this example, the `open()` function returns a file object, which is a context manager. When the `with` block is exited, the file is automatically closed.

You can create your own context managers using the `contextlib` module:

```python
from contextlib import contextmanager

@contextmanager
def my_context():
    print("Entering the context")
    yield
    print("Exiting the context")

with my_context():
    print("Inside the context")
```

## 6. Generators

Generators are a simple way to create iterators. They are defined like normal functions, but instead of returning a value, they `yield` it. When the generator is called, it returns an iterator object, but does not start execution immediately. The function continues from where it left off each time `__next__()` is called on the iterator.

Here's an example of a generator that yields the Fibonacci sequence:

```python
def fibonacci(count):
    a, b = 0, 1
    while count > 0:
        yield a
        a, b = b, a + b
        count -= 1

# Generate the first 10 Fibonacci numbers
fib = fibonacci(10)

for num in fib:
    print(num)
```

## 7. Multithreading and Multiprocessing

Python provides the `threading` and `multiprocessing` modules to work with threads and processes, respectively. Threads are lightweight, but they have limitations due to the Global Interpreter Lock (GIL) in CPython. Processes, on the other hand, can take full advantage of multiple CPU cores but have higher overhead.

Here's an example of using threads to download multiple files concurrently:

```python
import threading
import urllib.request

urls = [
    "https://example.com/file1.txt",
    "https://example.com/file2.txt",
    "https://example.com/file3.txt",
]

def download_file(url):
    urllib.request.urlretrieve(url, url.split("/")[-1])

# Create and start the threads
threads = []
for url in urls:
    t = threading.Thread(target=download_file, args=(url,))
    t.start()
    threads.append(t)

# Wait for all threads to finish
for t in threads:
    t.join()

print("All files downloaded.")
```

And here's an example of using processes to calculate the factorial of several numbers:

```python
import multiprocessing

def factorial(n, return_dict):
    result = 1
    for i in range(1, n + 1):
        result *= i
    return_dict[n] = result

numbers = [5, 7, 10]

# Create and start the processes
processes = []
manager = multiprocessing.Manager()
return_dict = manager.dict()

for num in numbers:
    p = multiprocessing.Process(target=factorial, args=(num, return_dict))
    p.start()
    processes.append(p)

# Wait for all processes to finish
for p in processes:
    p.join()

print("Factorials:")
for num in numbers:
    print(f"{num}: {return_dict[num]}")
```

## 8. Working with Files (Reading and Writing)

To read and write files in Python, you can use the built-in `open()` function. The `open()` function takes two arguments: the file path and the mode in which the file is opened.

Here's an example of how to write some text to a file:

```python
with open("file.txt", "w") as file:
    file.write("Hello, World!")
```

And here's how to read the content of a file:

```python
with open("file.txt", "r") as file:
    content = file.read()
    print(content)
```

## 9. Regular Expressions

Regular expressions are used to perform search, replace, and validation operations on text data. The `re` module in Python provides functions to work with regular expressions.

Here's an example of using regular expressions to check if a string is a valid email address:

```python
import re

email_pattern = r"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$"

email = "user@example.com"

if re.match(email_pattern, email):
    print("Valid email address")
else:
    print("Invalid email address")
```

## 10. Error Handling and Exceptions

Error handling is an essential part of programming. In Python, errors are handled through exceptions. Exceptions are events that are triggered when an error occurs during the execution of a program. You can handle exceptions using the `try` and `except` statements.

Here's an example of handling exceptions:

```python
try:
    result = 1 / 0
except ZeroDivisionError:
    print("Error: Division by zero.")
```

You can catch multiple exceptions by specifying them in a tuple:

```python
try:
    result = 1 / "string"
except (ZeroDivisionError, TypeError):
    print("Error: Invalid operation.")
```

You can also use the `finally` block to specify code that should run regardless of whether an exception was raised or not:

```python

try:
    result = 1 / 2
except ZeroDivisionError:
    print("Error: Division by zero.")
finally:
    print("This will be executed no matter what.")
```
# <u>Section 2: Classes</u>

## 11. Classes and Objects

Object-oriented programming (OOP) is a programming paradigm that uses objects, which are instances of classes, to represent and manipulate data. Python supports OOP through its class system.

Here's an example of a class definition and object creation:

```python
class Dog:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def bark(self):
        print(f"{self.name} says Woof!")

my_dog = Dog("Buddy", 3)
my_dog.bark()
```

In this example, we define a `Dog` class with an `__init__` method, which is the constructor, and a `bark` method. We then create an instance of the `Dog` class and call its `bark` method.

## 12. Inheritance

Inheritance is a way to create a new class that is a modified version of an existing class. The new class is called the subclass, and the existing class is the superclass.

Here's an example of inheritance:

```python
class Animal:
    def __init__(self, name):
        self.name = name

    def speak(self):
        raise NotImplementedError("Subclass must implement this method")

class Dog(Animal):
    def speak(self):
        return f"{self.name} says Woof!"

class Cat(Animal):
    def speak(self):
        return f"{self.name} says Meow!"

dog = Dog("Buddy")
cat = Cat("Whiskers")

print(dog.speak())  # Output: Buddy says Woof!
print(cat.speak())  # Output: Whiskers says Meow!
```

In this example, we define a base class `Animal` and two subclasses `Dog` and `Cat`. The subclasses override the `speak` method to provide their own implementation.

## 13. Property Decorators

Property decorators allow you to define methods in a class that are accessed like attributes. This can be useful for calculated properties or when you want to enforce certain conditions on attribute values.

Here's an example of using property decorators:

```python
class Circle:
    def __init__(self, radius):
        self._radius = radius

    @property
    def radius(self):
        return self._radius

    @radius.setter
    def radius(self, value):
        if value < 0:
            raise ValueError("Radius cannot be negative")
        self._radius = value

    @property
    def diameter(self):
        return self._radius * 2

    @property
    def area(self):
        return 3.14159 * self._radius * self._radius

circle = Circle(5)
print(circle.radius)     # Output: 5
print(circle.diameter)   # Output: 10
print(circle.area)       # Output: 78.53975
circle.radius = 10       # Set the radius to 10
print(circle.diameter)   # Output: 20
```

In this example, we define a `Circle` class with `radius`, `diameter`, and `area` properties. The `radius` property uses a setter to validate the input value.

## 14. Python's Data Model & Magic Methods

Python's data model allows you to define how your objects behave with respect to certain operations by implementing special methods, also known as magic or dunder (double underscore) methods.

Here's an example of implementing magic methods for a custom `Fraction` class:

```python
class Fraction:
    def __init__(self, numerator, denominator):
        self.numerator = numerator
        self.denominator = denominator

    def __str__(self):
        return f"{self.numerator}/{self.denominator}"

    def __add__(self, other):
        if isinstance(other, Fraction):
            num = self.numerator * other.denominator + other.numerator * self.denominator
            denom = self.denominator * other.denominator
            return Fraction(num, denom)
        else:
            raise TypeError("Invalid type")

f1 = Fraction(1, 2)
f2 = Fraction(1, 3)

f3 = f1 + f2
print(f3)  # Output: 5/6
```

In this example, we implement the `__str__` magic method to represent the `Fraction` object as a string, and the `__add__` magic method to add two fractions.

That's it! You've learned some advanced Python concepts and techniques. You can now use Google Colab to experiment with these concepts and build more complex projects. Good luck!
"""